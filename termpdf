#!/usr/bin/env bash
###########################################################################
# termpdf is a barebones in-line graphical pdf viewer for terminals that
# support in-line graphics.
#
# It currently supports pdf, djvu, and tif files.
#
# On X11, termpdf uses the w3mimgdisplay program supplied with the w3m 
# browser. On OSX, termpdf relies on iTerm2's support of inline images 
# (in iTerm 2.9 or later).
# 
###########################################################################

# SETTINGS

# pixel-to-character conversion factors (for X11) 
y_factor=18
x_factor=9
# density for PDF conversion. Higher density means sharper images,
# but might lead to slower performance.
density=300 

wrap="false" # default is not to pipe text through wrap in text mode 
# default pager is cat. secondary pager is less: a lot more power, but
# clunky integration with termpdf. 
text_pagers[0]="cat"
text_pagers[1]="less -XFRE"
# halo is the number of pages before and after the current page that will
# be converted in the background.
halo=2
display="image" # default is to display images not text

##################
# iTerm2
#################

# The following two functions are borrowed from the imgcat script at
# 
#   https://raw.githubusercontent.com/gnachman/iTerm2/master/tests/imgcat
#
# tmux requires unrecognized OSC sequences to be wrapped with DCS tmux;
# <sequence> ST, and for all ESCs in <sequence> to be replaced with ESC ESC. It
# only accepts ESC backslash for ST.
function print_osc() {
if [[ $TERM == screen* ]] ; then
    printf "\033Ptmux;\033\033]"
else
    printf "\033]"
fi
}

function print_st() {
if [[ $TERM == screen* ]] ; then
    printf "\a\033\\"
else
    printf "\a"
fi
}

# This function is also borrowed from imgcat, but I've added support
# for specifying width and height.
#
# print_image filename inline base64contents
#   filename: Filename to convey to client
#   inline: 0 or 1
#   base64contents: Base64-encoded contents
function print_image_iterm() {
print_osc
printf '1337;File='
if [[ -n "$1" ]]; then
    printf 'name='`echo -n "$1" | base64`";"
fi
if $(base64 --version 2>&1 | grep GNU > /dev/null)
then
    BASE64ARG=-d
else
    BASE64ARG=-D
fi
echo -n "$3" | base64 $BASE64ARG | wc -c | awk '{printf "size=%d",$1}'
printf ";inline=$2"
printf ";width=$width"
printf ";height=$height"
printf ":"
echo "$3"
print_st
printf '\n'
}

##################
# w3mimgdisplay
##################

function print_image_w3m() {
    #get the ratio of width to height for image
    img_factor=$(convert "$tmp_file" -ping -format "scale=3; %w / %h\n" info: | bc)  
    #get ratio of width to height for our terminal/tmux pane
    screen_factor=$(echo "scale=3; ($width * $x_factor) / ($height * $y_factor)" | bc)
    if [ $(echo "$img_factor < $screen_factor" | bc) == 1 ]; then
        # set height to max, set width proportional to height
        h=$[$height * y_factor]
        w=$(echo "$img_factor * $h" | bc | sed 's/\..*//')
    else
        # set width to max, height proportional to width
        w=$[$width * x_factor]
        h=$(echo "$w / $img_factor" | bc)
       echo
    fi
    term_px=$(echo -e '\e[14t')
    term_char=$(echo -e '\e[19t')
    printf "0;1;0;15;$w;$h;;;;;$tmp_file\n4;\n3;" | w3mimgdisplay
}



###################
# print image
###################

function print_image() {
    os=$(uname)
    if [[ $os == 'Darwin' ]]; then
        print_image_iterm $@
    else
        print_image_w3m $@
    fi
}


################
# Text Search
################

# A simple function that uses pdfgrep to search pdfs
function search_pdf() {
read -p "Find: " text
if [[ $text != "" ]]; then
    results=( $(pdfgrep -nip "$text" "$input_file" | sed 's|:.*||') )
fi
if [ ${#results[@]} -gt 0 ]; then
    index=0
else 
    index=-1
fi
}

# A function for finding text using the appropriate tool
function find_text() {
case $ft in
    pdf)
        search_pdf
        ;;
    djvu|tif|tiff)
        echo "search function not available for djvu or tif files" 
        ;;
esac
}

# A function for yanking text from current page to clipboard
function yank_page() {
case $ft in
    pdf)
        pdftotext -f $n -l $n -layout "$input_file" - | pbcopy
        tput cup 0 0
        echo "Page copied"
        ;;
    djvu)
        djvutxt -page=$n "$input_file" | pbcopy
        tput cup 0 0
        echo "Page copied"
        ;;
esac
}
# A function for getting the dimensions of the current terminal
# window or pane.
function get_pane_size() {
width=$(tput cols)
height=$(stty size | awk '{print $1}')
width=$(expr $width - 1)
height=$(expr $height - 1 )
}

#################
# Pages
#################

function get_pages() {
case $ft in
    pdf)
        pages=$(pdfinfo "$input_file" 2>/dev/null \
            | grep "^Pages:" | awk '{print $2}') 
        ;;
    djvu)
        pages=$(djvudump "$input_file" 2>/dev/null \
            | sed -n '2s/.*files //;s/ pages)//p')
        ;;
    tif|tiff)
        pages=$(tiffinfo "$input_file" 2>/dev/null \
            | sed -n 's/ *Page Number:.*-//p' | sed -n '1p')
        ;;
    *)
        pages=1 
        multipage='false'
esac
}

# A function for validiating page numbers
function page_limits() {
if [ "$n" -le 0 ]; then n=1; fi
if [ "$n" -ge "$pages" ]; then n="$pages"; fi
}

# Convert a page of a pdf to png. Using gs rather than 
# convert because it is supposedly faster. Also means that
# if you don't use the margin trimming feature, you don't need
# imagemagick.
function convert_pdf_gs() {
gs -dNumRenderingThreads=4 -dNOPAUSE -sDEVICE=png16m \
    -dFirstPage=$1 -dLastPage=$1 \
    -sOutputFile=${tmp_file_root}-$1.png -r$density \
    -q "${input_file}" -c quit 2>/dev/null
}

# 
function convert_page() {
for i in "$@"
do       
    if [[ ! -f "${tmp_file_root}-$i.png" ]]; then
        if [[ $i -le $pages && $i -ge 1 ]]; then
            case $ft in
                pdf)
                    if [[ $use_images == 'false' ]]; then
                        convert_pdf_gs "$i"
                    else
                        pdfimages -png -f $i -l $i "$input_file" "$tmp_file_root"
                        mv "$tmp_file_root-000.png" "$tmp_file_root-$i.png"
                    fi
                    ;;
                djvu)
                    djvups -page=$i "$input_file" \
                        | convert -flatten ps:- "${tmp_file_root}-$i.png"
                    ;;
                tif|tiff)
                    convert "${input_file}[$[$i - 1]]" "${tmp_file_root}-$i.png"
                    ;;
            esac
            # generate margin-trimmed version of the page
            convert -trim "$tmp_file_root-$i.png" \
                -bordercolor white -border 20x20 \
                "$tmp_file_root-trimmed-$i.png" 2>/dev/null
        fi
    fi
done
}

function convert_pdf_background() {
(
core=$n
k=1
while ((k<=halo))
do
    convert_page $[$core + $k] $[$core - $k]
    let k++
done
)&
}

function display_text_pdf() {
clear
if [[ $text_pager == 'cat' ]]; then
    pdftotext -f $n -l $n -layout "$input_file" - \
        | if [ $wrap == 'true' ]; then wrap -w $width; else cat; fi \
        | egrep --color "$text|\$" 
else
    pdftotext -f $n -l $n -layout "$input_file" - \
        | if [ $wrap == 'true' ]; then wrap -w $width; else cat; fi \
        | $text_pager $([[ $text ]] && -p$text)
fi
}

function display_text_djvu() {
clear
if [[ $text_pager == 'cat' ]]; then
    djvutxt -page=$n "$input_file" \
        | if [ $wrap == 'true' ]; then wrap -w $width; else cat; fi \
        | egrep --color "$text|\$" 
else
    djvutxt -page=$n "$input_file" \
        | if [ $wrap == 'true' ]; then wrap -w $width; else cat; fi \
        | $text_pager $([[ $text ]] && -p$text)
fi
}

function display_text() {
case $ft in
    pdf)
        display_text_pdf
        ;;
    djvu)
        display_text_djvu
        ;;
    tif|tiff)
        echo "Text display not available for tif files"
        ;;
esac
}

function check_dependencies() {
for app in gs pdftotext pdfimages pdfgrep pdfinfo convert 
do
    command -v $app >/dev/null 2>&1 ||\
        { echo >&2 "I require $app but it's not installed."; exit 1; } 
    done
}

function print_help() {
clear
tput cup 0 0
echo "j/k:         page back/forward"
echo "enter/space: page forward"
echo "g <number>:  go to page number"
echo "NNN:         go to page number NNN"
echo "r:           resize and redraw to fit pane"
echo "m:           toggle autocropped margins"
echo "t:           toggle text/image display"
echo "p:           toggle pager in text mode" 
echo "w:           toggle word-wrapping in text mode"
echo "y:           yank current page as text to clipboard"
echo "/ <expr>     go to page with first match for <expr>"
echo "n:           go to next match for <expr>"
echo "h:           print this help"
echo "q:           quit"
read -p "Press any key to return" -n 1 -s dummy
if [ $dummy == 'q' ]; then exit; fi
clear
}

function cli_help() {
echo "Usage: termpdf.sh [options] file.pdf"
echo
echo "   options:"
echo "      -h|--help:   show this help"
echo "      -t|--text:   display text instead of images"
echo "      -n <int>:    display page number <n>" 
exit
}


# Set some defaults
n=1 # start on page 1
text_pager=${text_pagers[0]}
results=( )
index=-1 
text="$" # null search text for egrep
trimmed="false" # set to true to default to trim margins

# Look for command line flags
while [ $# -gt 0 ]; do
    case "$1" in
        -h|--help)
            cli_help
            exit
            ;;
        -t|--text)
            display="text"
            ;;
        -n)
            shift
            if [[ "$1" != [0-9]* ]]; then
                echo "Must specify a page number with -n"
                exit
            else
                n="$1"
            fi
            ;;
        -*)
            echo "Unknown option: $1"
            cli_help
            exit
            ;;
        *)
            if [ -r "$1" ] ; then
                input_file="$1" 
                ft=${input_file##*.}
            else
                echo "$1: No such file or directory"
                exit
            fi
            ;;
    esac
    shift
done

check_dependencies

# Check to see that a file was specified on the cli
if [ ! -r "$input_file" ]; then cli_help; fi

# How many pages does the file have?
get_pages
# Does it look like it has page images?
use_images='false'
if [[ ft == 'pdf' ]]; then
    images=$(pdfimages -list "$input_file" | wc | awk '{print $1}')
    images=$[$images - 2]
    if [[ $pages == $images ]]; then use_images='true'; fi
fi

# Make a tmp_dir
tmp_dir=$(mktemp -d)
tmp_file_root="${tmp_dir}/tmp"

# clear the pane since we don't always fill it
clear


# display the PDF

while true
do
    # make sure the page we want exists
    page_limits
    # check the size of the pane
    get_pane_size
    # Convert page $n of the PDF
    convert_page $n
    # Convert surrounding pages in the background 
    convert_pdf_background 

    tput cup 0 1  # we leave a line at the top for commands

    if [[ $trimmed == 'true' ]]; then
        tmp_file="${tmp_file_root}-trimmed-$n.png"
    else
        tmp_file="${tmp_file_root}-$n.png"
    fi
    # display
    if [ $display == 'image' ]; then
        print_image "$tmp_file" 1 "$(base64 < "$tmp_file")" || {
        convert_page $n;
        print_image "$tmp_file" 1 "$(base64 < "$tmp_file")"
    }
else
    display_text $n
fi

tput cup 0 0 # put the cursor at the top of the pane
tput el # erase any old stuff from previous commands
tput cup 0 $(expr $width - ${#n} - ${#pages} - 1) # page num top right
echo "$n/$pages"
tput cup 0 0

read -n 1 command # await commands
if [[ $command == "" ]]; then command="k"; fi
case "$command" in
    j)
        n=$[$n - 1];; # go back a page
    k)
        let n++ ;; # go forward a page
    g)   
        read -p "Goto page: " pn # jump to a page
        if [[ "$pn" == [0-9]* ]]; then
            n="$pn"
        fi
        ;;
    [0-9])
        num=$command
        while read -n 1 -t 0.5 digit # get more digits
        do
            num="${num}${digit}"
        done
        n=$num
        ;;
    r)
        get_pane_size # clean up and resize to fit pane
        clear
        ;;
    t)
        if [ $display == "text" ]; then
            display="image"
        else
            display="text"
        fi
        clear
        ;;
    m)
        if [ $trimmed == "false" ]; then
            trimmed="true"
        else
            trimmed="false"
        fi
        ;;
    p)
        if [[ "$text_pager" == "${text_pagers[1]}" ]]; then
            text_pager="${text_pagers[0]}"
        else
            text_pager="${text_pagers[1]}"
        fi
        ;;
    w)
        if [ $wrap == "true" ]; then
            wrap="false"
        else
            wrap="true"
        fi
        ;;
    y)
        yank_page
        ;;
    '/') 
        find_text
        if [[ $index != -1 ]]; then
            n=${results[$index]}
        else
            tput cup 0 0
            echo "No matches"
        fi;;
    n)
        if [ $index != -1 ] && [ ${results[$[$index + 1]]} ]; then
            let index++
            n=${results[$index]} # go to next match
        else
            tput cup 0 0
            echo  "No matches"
        fi;;
    h)
        print_help
        ;;
    q)
        rm -rf "$tmp_dir"
        clear
        exit;;
esac
done

