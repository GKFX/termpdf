#!/usr/bin/env bash
###########################################################################
# termpdf is a barebones in-line graphical pdf viewer for terminals that
# support in-line graphics.
#
# It currently supports pdf, djvu, and tif files.
#
# On X11, termpdf uses the w3mimgdisplay program supplied with the w3m 
# browser. On OSX, termpdf relies on iTerm2's support of inline images 
# (in iTerm 2.9 or later).
# 
###########################################################################

###########################################################################
# SETTINGS
#
density=300 # set higher for sharper images (but a performance hit) 
#
display="image" # if you want to display text by default, set this to "text" 
#
print_command=lp
print_options=("-o sides=two-sided-long-edge")
#
text_conversion_method=pdftotext
#
wrap="false" # default is not to pipe text through wrap in text mode 
#
text_pagers[0]="cat" # default pager is 'cat'
#
text_pagers[1]="less -XFRE" # secondary pager is 'less'
#
halo=2 # number of pages out to convert in the background
#
declare -A keys
keys=(
  ["next-page"]="k"
  ["previous-page"]="j"
  ["goto-page"]="g"
  ["refresh-view"]="r"
  ["reload-document"]="R"
  ["crop-margins"]="m"
  ["text"]="t"
  ["horizontal-split"]="s"
  ["vertical-split"]="v"
  ["print"]="p"
  ["pager-toggle"]="l"
  ["wrap-toggle"]="w"
  ["yank-text"]="y"
  ["search"]="/"
  ["next-match"]="n"
  ["previous-match"]="N"
  ["help"]="?"
  ["debug"]="d"
  ["quit"]="q"
)
###########################################################################

###########################################################################
# Functions for displaying images in iTerm2
#
# The following two functions are borrowed from the imgcat script at
# 
#   https://raw.githubusercontent.com/gnachman/iTerm2/master/tests/imgcat
#
# tmux requires unrecognized OSC sequences to be wrapped with DCS tmux;
# <sequence> ST, and for all ESCs in <sequence> to be replaced with ESC ESC. It
# only accepts ESC backslash for ST.
function print_osc() {
if [[ $TERM == screen* ]] ; then
    printf "\033Ptmux;\033\033"
else
    printf "\033"
fi
}

function print_st() {
if [[ $TERM == screen* ]] ; then
    printf "\a\033\\"
else
    printf "\a"
fi
}

# This function is also borrowed from imgcat, but I've added support
# for specifying width and height.
#
# print_image filename inline base64contents
#   filename: Filename to convey to client
#   inline: 0 or 1
#   base64contents: Base64-encoded contents
function print_image_iterm() {
print_osc
printf ']1337;File='
if [[ -n "$1" ]]; then
    printf 'name='`echo -n "$1" | base64`";"
fi
if $(base64 --version 2>&1 | grep GNU > /dev/null)
then
    BASE64ARG=-d
else
    BASE64ARG=-D
fi
echo -n "$3" | base64 $BASE64ARG | wc -c | awk '{printf "size=%d",$1}'
printf ";inline=$2"
printf ";width=$width"
printf ";height=$height"
printf ":"
echo "$3"
print_st
printf '\n'
}
#
###########################################################################

###########################################################################
# Functions for displaying images using w3mimgdisplay
#
#
# function that gets important info about merm windows 
#
function get_xterm_info() { 
# move cursor to to left corner
tput cup 2 2 # but not 0 0, because that often breaks in tmux

# use escape codes to get window dimensions and cursor position
exec < /dev/tty
oldstty=$(stty -g)
stty raw -echo min 0 
print_osc > /dev/tty
printf "[14t" > /dev/tty # win size in pixels
print_st > /dev/tty
read -sr px_dim # win size in pixels
print_osc > /dev/tty
printf "[18t" > /dev/tty # win size in characters
print_st > /dev/tty
read char_dim # win size in characters
print_osc > /dev/tty
printf "[6n" > /dev/tty # cursor position in characters
print_st > /dev/tty
read curs_pos
stty $oldstty

# process the output
# window dimension in pixels
px_dim=${px_dim:2}
px_y=$(echo "$px_dim" | awk -F ';' '{print $2}')
px_x=$(echo "$px_dim" | awk -F ';' '{print $3}')
px_x=${px_x%?}
# window dimension in characters
char_dim=${char_dim:2}
char_y=$(echo "$char_dim" | awk -F ';' '{print $2}')
char_x=$(echo "$char_dim" | awk -F ';' '{print $3}')
char_x=${char_x%?}
# cursor position in characters
# (we need this to position images within tmux panes)
curs_pos=${curs_pos:2}
curs_y=$(echo "$curs_pos" | awk -F ';' '{print $1}')
curs_x=$(echo "$curs_pos" | awk -F ';' '{print $2}')
curs_x=${curs_x%?}
curs_x=$[$curs_x - 2]
curs_y=$[$curs_y - 2]
}

function get_xterm_font_factors() {
x_factor=$(echo "$px_x / ( $char_x + 1)" | bc)
y_factor=$(echo "$px_y / ( $char_y + 1)" | bc)
}

# get xterm position in pixels
function get_xterm_position() {
x_pos=$(echo "$curs_x * $x_factor" | bc)
y_pos=$(echo "$curs_y * $y_factor" | bc)
}

function print_image_w3m() {
    #get the ratio of width to height for image
    img_factor=$(convert "$tmp_file" -ping -format "scale=3; %w / %h\n" info: | bc)  
    #get ratio of width to height for our terminal/tmux pane
    screen_factor=$(echo "scale=3; ($width * $x_factor) / ($height * $y_factor)" | bc)
    if [ $(echo "$img_factor < $screen_factor" | bc) == 1 ]; then
        # set height to max, set width proportional to height
        h=$[$height * y_factor]
        w=$(echo "$img_factor * $h" | bc | sed 's/\..*//')
    else
        # set width to max, height proportional to width
        w=$[$width * x_factor]
        h=$(echo "$w / $img_factor" | bc)
       echo
    fi
    printf "0;1;$x_pos;$y_pos;$w;$h;;;;;$tmp_file\n4;\n3;" | w3mimgdisplay
}


###########################################################################


###########################################################################
# Function for displaying images, depending on OS
#
function print_image() {
    if [[ $os == 'Darwin' ]]; then
        print_image_iterm $@
    else
        print_image_w3m $@
    fi
}
#
###########################################################################


###########################################################################
# Functions for searching, yanking, text within documents 

# A simple function that uses pdfgrep to search pdfs
function search_pdf_old() {
read -p "Find: " text
if [[ $text != "" ]]; then
    results=( $(pdfgrep -nip "$text" "$input_file" | sed 's|:.*||') )
fi
if [ ${#results[@]} -gt 0 ]; then
    index=0
else 
    index=-1
fi
}

# A simple function that uses pdfgrep to search pdfs
function search_pdf() {
read -p "Find: " text
if [[ $text != "" ]]; then
    IFS=$'\n' results=( $(pdfgrep -niC $[$width - 10] "$text" "$input_file") )
fi
if [ ${#results[@]} -gt 0 ]; then
    index=0
else 
    index=-1
fi
}

# A function for finding text using the appropriate tool
function find_text() {
case $ft in
    pdf)
        search_pdf
        ;;
    djvu|tif|tiff)
        echo "search function not available for djvu or tif files" 
        ;;
esac
}

# A function for yanking text from current page to clipboard
function yank_page() {
case $ft in
    pdf)
        pdftotext -f $n -l $n -layout "$input_file" - | pbcopy
        tput cup 0 0
        echo "Page copied"
        ;;
    djvu)
        djvutxt -page=$n "$input_file" | pbcopy
        tput cup 0 0
        echo "Page copied"
        ;;
esac
}
#
###########################################################################


###########################################################################
# A function for getting the dimensions of the current terminal
# window or pane.
function get_pane_size() {
width=$(tput cols)
height=$(stty size | awk '{print $1}')
width=$(expr $width - 1)
height=$(expr $height - 1 )
}
###########################################################################

###########################################################################
# Functions for dealing with pages
#
function get_pages() {
case $ft in
    pdf)
        pages=$(pdfinfo "$input_file" 2>/dev/null \
            | grep "^Pages:" | awk '{print $2}') 
        ;;
    djvu)
        pages=$(djvudump "$input_file" 2>/dev/null \
            | sed -n '2s/.*files //;s/ pages)//p')
        ;;
    tif|tiff)
        pages=$(tiffinfo "$input_file" 2>/dev/null \
            | sed -n 's/ *Page Number:.*-//p' | sed -n '1p')
        ;;
    *)
        pages=1 
        multipage='false'
esac
}

# A function for validiating page numbers
function page_limits() {
if [ "${n%B}" -le 0 ]; then n=1; fi
if [ "${n%B}" -ge "$pages" ]; then n="$pages"; fi
}
#
###########################################################################

###########################################################################
# Image conversion functions
#

function convert_pdf_cairo() {
pdftocairo -f $1 -l $1 -png -singlefile "$input_file" "${tmp_file_root}-$1"
if [[ $split == 'vert' || $split == 'horiz' ]]; then
    if [[ $split == 'vert' ]]; then geo='50%x100%'; fi
    if [[ $split == 'horiz' ]]; then geo='100%x50%'; fi
    convert -crop $geo +repage \
        ${tmp_file_root}-$1.png ${tmp_file_root}-$1-%d.png 
    mv ${tmp_file_root}-$1-0.png ${tmp_file_root}-$1.png
    mv ${tmp_file_root}-$1-1.png ${tmp_file_root}-$1B.png
fi
}

# 
function convert_page() {
for i in "$@"
do       
    if [[ ! -f "${tmp_file_root}-$i.png" ]]; then
        if [[ $i -le $pages && $i -ge 1 ]]; then
            case $ft in
                pdf)
                    convert_pdf_cairo "$i"
                    ;;
                djvu)
                    djvups -page=$i "$input_file" \
                        | convert -flatten ps:- "${tmp_file_root}-$i.png"
                    ;;
                tif|tiff)
                    convert -flatten "${input_file}[$[$i - 1]]" "${tmp_file_root}-$i.png"
                    ;;
                png)
                    cp "${input_file}" "${tmp_file_root}-$i.png" 
                    ;;
                *)
                    if [[ $os == 'Darwin' ]]; then
                        sips -s format png "${input_file}" --out "${tmp_file_root}-$i.png"
                    else
                        convert "${input_file}" "${tmp_file_root}-$i.png"
                    fi
                    ;;
            esac
            # generate margin-trimmed version of the page
            convert -trim "$tmp_file_root-$i.png" \
                -bordercolor white -border 20x20 \
                "$tmp_file_root-trimmed-$i.png" 2>/dev/null
            if [[ "$split" == "vert" || $split == "horiz" ]]; then
                convert -trim "$tmp_file_root-$iB.png" \
                -bordercolor white -border 20x20 \
                "$tmp_file_root-trimmed-$iB.png" 2>/dev/null
            fi
        fi
    fi
done
}

function convert_background() {
(
core=${n%B}
k=1
while ((k<=halo))
do
    convert_page $[$core + $k] $[$core - $k] 
    let k++
done
)&
}
#
###########################################################################

###########################################################################
# Text Conversion and Display functions
#
function convert_pdf_to_text() {
case $1 in
    pdftotext)
        pdftotext -f $n -l $n -layout "$input_file" -
        ;;
    html-pandoc)
        pdftohtml -f $n -l $n -i -noframes "$input_file" -stdout \
            | pandoc -f html -t plain --no-wrap
        ;;
esac
}
        
function display_text_pdf() {
clear

text_conversion_method="pdftotext"

if [[ $text_pager == 'cat' ]]; then
    convert_pdf_to_text $text_conversion_method \
        | if [ $wrap == 'true' ]; then wrap -w $width; else cat; fi \
        | egrep --color "$text|\$" 
else
    convert_pdf_to_text $text_conversion_method \
        | if [ $wrap == 'true' ]; then wrap -w $width; else cat; fi \
        | $text_pager $([[ $text ]] && -p$text)
fi
}

function display_text_djvu() {
clear
if [[ $text_pager == 'cat' ]]; then
    djvutxt -page=$n "$input_file" \
        | if [ $wrap == 'true' ]; then wrap -w $width; else cat; fi \
        | egrep --color "$text|\$" 
else
    djvutxt -page=$n "$input_file" \
        | if [ $wrap == 'true' ]; then wrap -w $width; else cat; fi \
        | $text_pager $([[ $text ]] && -p$text)
fi
}

function display_text() {
case $ft in
    pdf)
        display_text_pdf
        ;;
    djvu)
        display_text_djvu
        ;;
    tif|tiff)
        echo "Text display not available for tif files"
        ;;
esac
}
#
###########################################################################

###########################################################################
# Miscellaneous functions
#
function refresh_file() {
rm "${tmp_dir}/tmp"*
}

function print_file() {
echo " ...printing..."
tput cup 0 0
$print_command ${print_options[@]} "$input_file"
}

function check_dependencies() {

case $ft in
    pdf)
        dep_list="gs pdftotext pdfgrep pdfinfo convert"
        ;;
    djvu)
        dep_list="djvups djvutxt djvudump convert"
        ;;
    tif)
        dep_list="convert"
        ;;
esac

os=$(uname)
if [[ $os != "Darwin" ]]; then
    dep_list="$dep_list bc w3mimgdisplay"
fi

for app in $dep_list
do
    command -v $app >/dev/null 2>&1 ||\
        { echo >&2 "termpdf requires $app but it's not installed."; exit 1; } 
    done
}

function print_help() {
clear
tput cup 0 0
echo "${keys['previous-page']}/${keys['next-page']}:         page back/forward"
echo "enter/space: page forward"
echo "${keys['goto-page']} <number>:  go to page number"
echo "NNN:         go to page number NNN"
echo "${keys['search']} <expr>:    go to page with first match for <expr>"
echo "${keys['next-match']}:           go to next match for <expr>"
#echo "${keys['previous-match']}:           go to previous match for <expr>"
echo "${keys['refresh-view']}:           refresh display"
echo "${keys['reload-document']}:           reload document"
echo "${keys['crop-margins']}:           toggle autocropped margins"
echo "${keys['text']}:           toggle text/image display"
echo "${keys['horizontal-split']}:           split pages horizontally"
echo "${keys['vertical-split']}:           split pages vertically"
echo "${keys['print']}:           print document"
echo "${keys['pager-toggle']}:           toggle pager in text mode" 
echo "${keys['wrap-toggle']}:           toggle word-wrapping in text mode"
echo "${keys['yank-text']}:           yank current page as text to clipboard"
echo "${keys['help']}:           help"
echo "${keys['quit']}:           quit"
read -p "Press any key to return" -n 1 -s dummy
if [ $dummy == 'q' ]; then exit; fi
clear
}

function cli_help() {
echo "Usage: termpdf.sh [options] file.pdf"
echo
echo "   options:"
echo "      -h|--help:   show this help"
echo "      -t|--text:   display text instead of images"
echo "      -n <int>:    display page number <n>" 
exit
}

function clean_and_exit() {
rm -rf "$tmp_dir"
clear
exit
}

function get_window_info() {
get_pane_size
if [[ "$os" != "Darwin" ]]; then
    get_xterm_info
    get_xterm_font_factors
    get_xterm_position
fi
}

function debug() {
return
}

#
###########################################################################

###########################################################################
# Main program
#
# Set some defaults
n=1 # start on page 1
text_pager=${text_pagers[0]}
results=( )
index=-1 
text="$" # null search text for egrep
trimmed="false" # set to true to default to trim margins


# Look for command line flags
while [ $# -gt 0 ]; do
    case "$1" in
        -h|--help)
            cli_help
            exit
            ;;
        -t|--text)
            display="text"
            ;;
        -n)
            shift
            if [[ "$1" != [0-9]* ]]; then
                echo "Must specify a page number with -n"
                exit
            else
                n="$1"
            fi
            ;;
        -*)
            echo "Unknown option: $1"
            cli_help
            exit
            ;;
        *)
            if [ -r "$1" ] ; then
                input_file="$1" 
                ft=${input_file##*.}
            else
                echo "$1: No such file or directory"
                exit
            fi
            ;;
    esac
    shift
done

# Check to see that a file was specified on the cli
if [ ! -r "$input_file" ]; then cli_help; fi

check_dependencies

# How many pages does the file have?
get_pages

# Make a tmp_dir
tmp_dir=$(mktemp -d)
tmp_file_root="${tmp_dir}/tmp"

# Postscript? Convert to PDF and relaunch
if [[ $ft == 'ps' ]]; then
    ps2pdf "$input_file" "${tmp_dir}/tmp.pdf"
    $0 "${tmp_dir}/tmp.pdf"
    clean_and_exit 
fi

# clear the pane since we don't always fill it
clear


# display the document 

while true
do
    # make sure the page we want exists
    page_limits
    # check the size of the pane, window, etc
    get_window_info
    # Convert the page to be displayed
    convert_page $n
    # Start converting surrounding pages in the background 
    convert_background 
    tput cup 0 1  # we leave a line at the top for commands
    
    if [[ $trimmed == 'true' ]]; then
        tmp_file="${tmp_file_root}-trimmed-$n.png"
    else
        tmp_file="${tmp_file_root}-$n.png"
    fi
    # display
    if [ $display == 'image' ]; then
        print_image "$tmp_file" 1 "$(base64 < "$tmp_file")" || {
        convert_page $n;
        print_image "$tmp_file" 1 "$(base64 < "$tmp_file")"
    }
    else
        display_text $n
    fi

tput cup 0 0 # put the cursor at the top of the pane
tput el # erase any old stuff from previous commands
tput cup 0 $(expr $width - ${#n} - ${#pages} - 1) # page num top right
echo "$n/$pages"
tput cup 0 0

read -n 1 command # await commands
if [[ $command == "" ]]; then command="k"; fi
case "$command" in
    "${keys['previous-page']}")
        if [[ $n =~ B$ ]]; then
            n=${n%B}
        else
            n=$[$n - 1]
        fi
        ;; # go back a page
    "${keys['next-page']}")
        if [[ $n =~ B$ ]]; then
            n=$[${n%B} + 1]
        elif [[ $split == "vert" || $split == horiz ]]; then
            n="${n}B"
        else
            let n++
        fi
        ;;
    "${keys['goto-page']}")   
        read -p "Goto page: " pn # jump to a page
        if [[ "$pn" == [0-9]* ]]; then
            n="$pn"
        fi
        ;;
    [0-9])
        num=$command
        while read -n 1 -t 0.5 digit # get more digits
        do
            num="${num}${digit}"
        done
        n=$num
        ;;
    "${keys['refresh-view']}")
        get_window_info # clean up and resize to fit pane
        clear
        ;;
    "${keys['reload-document']}")
        refresh_file # reload file 
        clear
        ;;
    "${keys['text']}")
        if [ $display == "text" ]; then
            display="image"
        else
            display="text"
        fi
        clear
        ;;
    "${keys['crop-margins']}")
        if [ $trimmed == "false" ]; then
            trimmed="true"
        else
            trimmed="false"
        fi
        ;;
    "${keys['pager-toggle']}")
        if [[ "$text_pager" == "${text_pagers[1]}" ]]; then
            text_pager="${text_pagers[0]}"
        else
            text_pager="${text_pagers[1]}"
        fi
        ;;
    "${keys['horizontal-split']}")
        refresh_file
        if [[ $split == "horiz" ]]; then
            split="false"
            n=${n%B}
        else
            split="horiz"
        fi
        ;;
    "${keys['vertical-split']}")
        refresh_file
        if [[ $split == "vert" ]]; then
            split="false"
            n=${n%B}
        else
            split="vert"
        fi
        ;;
    "${keys['print']}")
        print_file
        ;;
    "${keys['wrap-toggle']}")
        if [ $wrap == "true" ]; then
            wrap="false"
        else
            wrap="true"
        fi
        ;;
    "${keys['yank-text']}")
        yank_page
        ;;
    "${keys['search']}") 
        find_text
        if [[ $index != -1 ]]; then
            n=${results[$index]%%:*}
        else
            tput cup 0 0
            echo "No matches"
        fi;;
    "${keys['next-match']}")
        if [ $index != -1 ] && [ ${results[$[$index + 1]]} ]; then
            let index++
            n=${results[$index]%%:*} # go to next match
        else
            tput cup 0 0
            echo  "No matches"
        fi
        ;;
    "${keys['previous-match']}")
        if [ $index != -1 ] && [ ${results[$[$index - 1]]} ]; then
            index=$[$index - 1]
            n=${results[$index]%%:*} # go to previous match
        else
            tput cup 0 0
            echo  "No matches"
        fi;;
    "${keys['help']}")
        print_help
        ;;
    "${keys['debug']}")
        debug
        ;;
    "${keys['quit']}")
        clean_and_exit
        ;;
esac
done

